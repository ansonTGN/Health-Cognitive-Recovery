use axum::{
    extract::{State, Query},
    response::{IntoResponse, Response},
    http::header,
};
use serde_json::json;
use xml::writer::{EmitterConfig, XmlEvent};
use std::io::Cursor;

use crate::domain::{
    errors::AppError,
    models::{ExportParams, ExportFormat, ExportedGraph},
};
use super::admin::AppState;

#[utoipa::path(
    get,
    path = "/api/export",
    params(ExportParams),
    responses(
        (status = 200, description = "Knowledge Graph Exported"),
        (status = 500, description = "Internal error")
    ),
    tag = "export"
)]
pub async fn export_knowledge_graph(
    State(state): State<AppState>, // <-- Sin Arc<>
    Query(params): Query<ExportParams>,
) -> Result<Response, AppError> {
    
    let graph = state.repo.export_full_knowledge_graph().await?;
    let format = params.format.unwrap_or(ExportFormat::JsonLd);

    match format {
        ExportFormat::JsonLd => export_jsonld(graph),
        ExportFormat::Turtle => export_turtle(graph),
        ExportFormat::GraphML => export_graphml(graph),
    }
}

// ... (El resto de funciones auxiliares export_jsonld, export_turtle, export_graphml 
// permanecen IGUAL que antes, no necesitan cambios)
fn export_jsonld(graph: ExportedGraph) -> Result<Response, AppError> {
    let context = json!({
        "@context": {
            "schema": "http://schema.org/",
            "mhealth": "http://ontologies.lamuralla.org/mental-health#",
            "Person": "mhealth:Person",
            "Condition": "mhealth:Condition",
            "Intervention": "mhealth:Intervention",
            "CommunityResource": "mhealth:CommunityResource",
            "Outcome": "mhealth:Outcome",
            "Concept": "mhealth:Concept",
            "name": "schema:name",
            "category": "@type",
            "relations": { "@id": "mhealth:relations", "@type": "@id" }
        }
    });

    let mut nodes_map = serde_json::Map::new();

    for node in &graph.nodes {
        let id = format!("mhealth:{}", sanitize_uri(&node.name));
        let type_uri = format!("mhealth:{}", node.category);
        
        let node_json = json!({
            "@id": id,
            "@type": type_uri,
            "name": node.name,
            "category": node.category 
        });
        
        nodes_map.insert(id, node_json);
    }

    let mut edges_json = Vec::new();
    for edge in &graph.edges {
        edges_json.push(json!({
            "source": format!("mhealth:{}", sanitize_uri(&edge.source)),
            "target": format!("mhealth:{}", sanitize_uri(&edge.target)),
            "relation": edge.relation_type
        }));
    }

    let final_json = json!({
        "@context": context["@context"],
        "@graph": nodes_map.values().collect::<Vec<_>>(),
        "meta:topology": edges_json 
    });

    let body = serde_json::to_string_pretty(&final_json)
        .map_err(|e| AppError::ParseError(e.to_string()))?;

    Ok((
        [(header::CONTENT_TYPE, "application/ld+json"), 
         (header::CONTENT_DISPOSITION, "attachment; filename=\"ontology.jsonld\"")],
        body
    ).into_response())
}

fn export_turtle(graph: ExportedGraph) -> Result<Response, AppError> {
    let mut ttl = String::new();

    ttl.push_str("@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n");
    ttl.push_str("@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n");
    ttl.push_str("@prefix mhealth: <http://ontologies.lamuralla.org/mental-health#> .\n\n");

    ttl.push_str(&format!("# Generated by LaMuralla Engine at {}\n\n", graph.generated_at));

    ttl.push_str("# --- Ontology Classes ---\n");
    let categories = ["Person", "Condition", "Intervention", "Outcome", "CommunityResource", "Concept"];
    for cat in categories {
        ttl.push_str(&format!("mhealth:{} a rdfs:Class .\n", cat));
    }
    ttl.push_str("\n# --- Instances ---\n");

    for node in &graph.nodes {
        let subject = format!("mhealth:{}", sanitize_uri(&node.name));
        let type_class = format!("mhealth:{}", node.category);
        ttl.push_str(&format!("{} a {} ;\n", subject, type_class));
        ttl.push_str(&format!("    rdfs:label \"{}\" .\n", node.name));
    }

    ttl.push_str("\n# --- Relationships ---\n");

    for edge in &graph.edges {
        let source = format!("mhealth:{}", sanitize_uri(&edge.source));
        let target = format!("mhealth:{}", sanitize_uri(&edge.target));
        let predicate = format!("mhealth:{}", to_camel_case(&edge.relation_type));

        ttl.push_str(&format!("{} {} {} .\n", source, predicate, target));
    }

    Ok((
        [(header::CONTENT_TYPE, "text/turtle"), 
         (header::CONTENT_DISPOSITION, "attachment; filename=\"ontology.ttl\"")],
        ttl
    ).into_response())
}

fn export_graphml(graph: ExportedGraph) -> Result<Response, AppError> {
    let mut writer = Cursor::new(Vec::new());
    let config = EmitterConfig::new().perform_indent(true);
    let mut xml = config.create_writer(&mut writer);

    xml.write(XmlEvent::start_element("graphml")
        .attr("xmlns", "http://graphml.graphdrawing.org/xmlns")
        .attr("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance")
    ).map_err(|e| AppError::ParseError(e.to_string()))?;

    xml.write(XmlEvent::start_element("key").attr("id", "d0").attr("for", "node").attr("attr.name", "category").attr("attr.type", "string")).ok();
    xml.write(XmlEvent::start_element("key").attr("id", "d1").attr("for", "edge").attr("attr.name", "label").attr("attr.type", "string")).ok();

    xml.write(XmlEvent::start_element("graph").attr("id", "G").attr("edgedefault", "directed")).ok();

    for node in &graph.nodes {
        let id = sanitize_uri(&node.name); 
        xml.write(XmlEvent::start_element("node").attr("id", &id)).ok();
        xml.write(XmlEvent::start_element("data").attr("key", "d0")).ok();
        xml.write(XmlEvent::characters(&node.category)).ok();
        xml.write(XmlEvent::end_element()).ok(); 
        xml.write(XmlEvent::end_element()).ok(); 
    }

    for (i, edge) in graph.edges.iter().enumerate() {
        let source = sanitize_uri(&edge.source);
        let target = sanitize_uri(&edge.target);
        let edge_id = format!("e{}", i);

        xml.write(XmlEvent::start_element("edge")
            .attr("id", &edge_id)
            .attr("source", &source)
            .attr("target", &target)
        ).ok();

        xml.write(XmlEvent::start_element("data").attr("key", "d1")).ok();
        xml.write(XmlEvent::characters(&edge.relation_type)).ok();
        xml.write(XmlEvent::end_element()).ok();
        xml.write(XmlEvent::end_element()).ok(); 
    }

    xml.write(XmlEvent::end_element()).ok(); 
    xml.write(XmlEvent::end_element()).ok(); 

    let result_string = String::from_utf8(writer.into_inner())
        .map_err(|e| AppError::ParseError(e.to_string()))?;

    Ok((
        [(header::CONTENT_TYPE, "application/xml"), 
         (header::CONTENT_DISPOSITION, "attachment; filename=\"network.graphml\"")],
        result_string
    ).into_response())
}

fn sanitize_uri(input: &str) -> String {
    input.trim()
        .replace(" ", "_")
        .replace("\"", "")
        .replace("<", "")
        .replace(">", "")
        .replace("'", "")
}

fn to_camel_case(s: &str) -> String {
    let parts: Vec<&str> = s.split(|c| c == '_' || c == ' ').collect();
    if parts.is_empty() { return String::new(); }

    let mut result = parts[0].to_lowercase();
    for part in parts.iter().skip(1) {
        if !part.is_empty() {
            let (first, rest) = part.split_at(1);
            result.push_str(&first.to_uppercase());
            result.push_str(&rest.to_lowercase());
        }
    }
    result
}